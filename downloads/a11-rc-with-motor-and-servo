/* Edge Impulse Arduino examples
 * Copyright (c) 2021 EdgeImpulse Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 * 
 */
/* Includes ---------------------------------------------------------------- */
#include <ei-v20unknown-1popGoRight-2waterGoLeft-3fast-v2-0-0_inferencing.h>
#include "edge-impulse-advanced.h"
#include <Servo.h>
#include "mbed.h"
#include "rtos.h"

//using namespace mbed;  // sometimes needed
using namespace rtos;


// Global Variables
int myDelay = 0;  // delay between readings, can be zero, default 2000 = 2 seconds

Thread thread;

int myGlobalD4 = 0;

Servo myServo_D2;







void myLedBlue_thread(){
   while (true) {
      analogWrite(D4, myGlobalD4);
      ThisThread::sleep_for(50);
   }
}



/**
* @brief      Arduino setup function
*/
void setup()
{
     thread.start(myLedBlue_thread);
     
    // put your setup code here, to run once:
    Serial.begin(115200);
    Serial.println("Edge Impulse Inferencing Demo");
    myServo_D2.attach(D2);   // D2 should do PWM on Portenta
    
    pinMode(LEDR, OUTPUT); 
    pinMode(LEDG, OUTPUT);   // this is LED_BUILTIN
    pinMode(LEDB, OUTPUT); 
    pinMode(D3, OUTPUT);   // digital 0 to 1
    pinMode(D4, OUTPUT);   // PWM 0 to 255
    pinMode(D5, OUTPUT);   // digital 0 to 1
    
    digitalWrite(D5, 1);    // set one direction
    digitalWrite(D3, 0);    // set one direction 
       
#ifdef EI_CAMERA_FRAME_BUFFER_SDRAM
    // initialise the SDRAM
    SDRAM.begin(SDRAM_START_ADDRESS);
#endif

    if (ei_camera_init()) {
        Serial.println("Failed to initialize Camera!");
    }
    else {
        Serial.println("Camera initialized");
    }

    for (size_t ix = 0; ix < ei_dsp_blocks_size; ix++) {
        ei_model_dsp_t block = ei_dsp_blocks[ix];
        if (block.extract_fn == &extract_image_features) {
            ei_dsp_config_image_t config = *((ei_dsp_config_image_t*)block.config);
            int16_t channel_count = strcmp(config.channels, "Grayscale") == 0 ? 1 : 3;
            if (channel_count == 3) {
                Serial.println("WARN: You've deployed a color model, but the Arduino Portenta H7 only has a monochrome image sensor. Set your DSP block to 'Grayscale' for best performance.");
                break; // only print this once
            }
        }
    }
}

/**
* @brief      Get data and run inferencing
*
* @param[in]  debug  Get debug info if true
*/
void loop()
{
    Serial.println("Starting inferencing in "+String(myDelay)+" microseconds...");

    // instead of wait_ms, we'll wait on the signal, this allows threads to cancel us...
    if (ei_sleep(myDelay) != EI_IMPULSE_OK) {
        return;
    }


    ei::signal_t signal;
    signal.total_length = EI_CLASSIFIER_INPUT_WIDTH * EI_CLASSIFIER_INPUT_HEIGHT;
    signal.get_data = &ei_camera_cutout_get_data;

    if (ei_camera_capture((size_t)EI_CLASSIFIER_INPUT_WIDTH, (size_t)EI_CLASSIFIER_INPUT_HEIGHT, NULL) == false) {
        Serial.println("Failed to capture image\r\n");
        return;
    }

    // Run the classifier
    ei_impulse_result_t result = { 0 };

    EI_IMPULSE_ERROR err = run_classifier(&signal, &result, debug_nn);
    if (err != EI_IMPULSE_OK) {
        Serial.println("ERR: Failed to run classifier, error number: " + String(err));
        return;
    }


    int myBestClassificationNumber = -1;  
    float myBestClassificationValue = 0.25;   // lowest best allowable value
    
    
    // print the predictions
   // Serial.println("Predictions ");
    // For complex prints best to run Edge Impulse ei_printf
    ei_printf("(DSP: %d ms., Classification: %d ms., Anomaly: %d ms.)",
        result.timing.dsp, result.timing.classification, result.timing.anomaly);
    ei_printf(": \n");
    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
       // ei_printf("    %s: %.5f\n", result.classification[ix].label, result.classification[ix].value);

        if (result.classification[ix].value > myBestClassificationValue ){
           myBestClassificationNumber = ix;                      // find the biggest array value
           myBestClassificationValue = result.classification[ix].value;  
        }

  
    }
    
#if EI_CLASSIFIER_HAS_ANOMALY == 1
    Serial.println("    anomaly score: " + String(result.anomaly, 5));
#endif


    digitalWrite(LEDB, HIGH);   //on board LED's are turned off by HIGH    
    digitalWrite(LEDG, HIGH);   
    digitalWrite(LEDR, HIGH); 

    // I find it less confusing if the 0unknown does nothing
    if (myBestClassificationNumber == 0){    // 0 unknown do nothing
        digitalWrite(LEDR, LOW);    
        digitalWrite(LEDG, LOW);  
        //analogWrite(D4, 0);     // stop
        myGlobalD4 = 0; 
      ei_printf("0: Unknown Stop: %.5f\n", myBestClassificationValue);
    }


    if (myBestClassificationNumber == 1){   // 1pop: Go Right
      digitalWrite(LEDB, LOW);              // Blue LED on
      //analogWrite(D4, 30);     // slow 
      myGlobalD4 = 30;
      myServo_D2.write(110);   // go right
      ei_printf("1: Pop Go right: %.5f\n", myBestClassificationValue);
    }
    
    if (myBestClassificationNumber == 2){   // 2water : go left
      digitalWrite(LEDG, LOW);              // Green LED on     
      //analogWrite(D4, 30);     // slow 
      myGlobalD4 = 30;  
      myServo_D2.write(70);    // go left
      ei_printf("2: Water Go Left: %.5f\n", myBestClassificationValue);
    }
    
    if (myBestClassificationNumber == 3){   // 3fast got straight
      digitalWrite(LEDR, LOW);              // Red LED on  
     // analogWrite(D4, 30);     // medium   
      myGlobalD4 = 50;
      myServo_D2.write(90);    // straight   
      ei_printf("3: Both Go Fast: %.5f\n", myBestClassificationValue);
    }

    // put more if statements here for your model


}
